diff --git i/packages/opencode/src/tool/bash.ts w/packages/opencode/src/tool/bash.ts
index de1eedaa..27e85572 100644
--- i/packages/opencode/src/tool/bash.ts
+++ w/packages/opencode/src/tool/bash.ts
@@ -41,7 +41,14 @@ export const BashTool = Tool.define("bash", {
     const timeout = Math.min(params.timeout ?? DEFAULT_TIMEOUT, MAX_TIMEOUT)
     const app = App.info()
     const cfg = await Config.get()
-    const tree = await parser().then((p) => p.parse(params.command))
+
+    let tree = null
+    try {
+      tree = await parser().then((p) => p.parse(params.command))
+    } catch (e) {
+      log.warn(e)
+    }
+
     const permissions = (() => {
       const value = cfg.permission?.bash
       if (!value)
@@ -56,57 +63,60 @@ export const BashTool = Tool.define("bash", {
     })()

     let needsAsk = false
-    for (const node of tree.rootNode.descendantsOfType("command")) {
-      const command = []
-      for (let i = 0; i < node.childCount; i++) {
-        const child = node.child(i)
-        if (!child) continue
-        if (
-          child.type !== "command_name" &&
-          child.type !== "word" &&
-          child.type !== "string" &&
-          child.type !== "raw_string" &&
-          child.type !== "concatenation"
-        ) {
-          continue
+
+    if (tree) {
+      for (const node of tree.rootNode.descendantsOfType("command")) {
+        const command = []
+        for (let i = 0; i < node.childCount; i++) {
+          const child = node.child(i)
+          if (!child) continue
+          if (
+            child.type !== "command_name" &&
+            child.type !== "word" &&
+            child.type !== "string" &&
+            child.type !== "raw_string" &&
+            child.type !== "concatenation"
+          ) {
+            continue
+          }
+          command.push(child.text)
         }
-        command.push(child.text)
-      }

-      // not an exhaustive list, but covers most common cases
-      if (["cd", "rm", "cp", "mv", "mkdir", "touch", "chmod", "chown"].includes(command[0])) {
-        for (const arg of command.slice(1)) {
-          if (arg.startsWith("-") || (command[0] === "chmod" && arg.startsWith("+"))) continue
-          const resolved = await $`realpath ${arg}`
-            .quiet()
-            .nothrow()
-            .text()
-            .then((x) => x.trim())
-          log.info("resolved path", { arg, resolved })
-          if (resolved && !Filesystem.contains(app.path.cwd, resolved)) {
-            throw new Error(
-              `This command references paths outside of ${app.path.cwd} so it is not allowed to be executed.`,
-            )
+        // not an exhaustive list, but covers most common cases
+        if (["cd", "rm", "cp", "mv", "mkdir", "touch", "chmod", "chown"].includes(command[0])) {
+          for (const arg of command.slice(1)) {
+            if (arg.startsWith("-") || (command[0] === "chmod" && arg.startsWith("+"))) continue
+            const resolved = await $`realpath ${arg}`
+              .quiet()
+              .nothrow()
+              .text()
+              .then((x) => x.trim())
+            log.info("resolved path", { arg, resolved })
+            if (resolved && !Filesystem.contains(app.path.cwd, resolved)) {
+              throw new Error(
+                `This command references paths outside of ${app.path.cwd} so it is not allowed to be executed.`,
+              )
+            }
           }
         }
-      }

-      // always allow cd if it passes above check
-      if (!needsAsk && command[0] !== "cd") {
-        const action = (() => {
-          for (const [pattern, value] of Object.entries(permissions)) {
-            const match = Wildcard.match(node.text, pattern)
-            log.info("checking", { text: node.text.trim(), pattern, match })
-            if (match) return value
+        // always allow cd if it passes above check
+        if (!needsAsk && command[0] !== "cd") {
+          const action = (() => {
+            for (const [pattern, value] of Object.entries(permissions)) {
+              const match = Wildcard.match(node.text, pattern)
+              log.info("checking", { text: node.text.trim(), pattern, match })
+              if (match) return value
+            }
+            return "ask"
+          })()
+          if (action === "deny") {
+            throw new Error(
+              "The user has specifically restricted access to this command, you are not allowed to execute it.",
+            )
           }
-          return "ask"
-        })()
-        if (action === "deny") {
-          throw new Error(
-            "The user has specifically restricted access to this command, you are not allowed to execute it.",
-          )
+          if (action === "ask") needsAsk = true
         }
-        if (action === "ask") needsAsk = true
       }
     }
